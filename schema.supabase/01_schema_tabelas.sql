-- =============================================
-- SCHEMA DO BANCO DE DADOS - APPOPERACAO
-- Versão: 2.1 - Atualizado via MCP Supabase
-- Data: 2025-08-21
-- =============================================

-- Extensões necessárias
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =============================================
-- TABELAS PRINCIPAIS
-- =============================================

-- Tabela: colaboradores
CREATE TABLE IF NOT EXISTS colaboradores (
    id SERIAL PRIMARY KEY,
    nome TEXT NOT NULL,
    funcao TEXT NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    matricula INTEGER UNIQUE,
    user_id UUID UNIQUE REFERENCES auth.users(id),
    supervisor_id INTEGER REFERENCES colaboradores(id),
    coordenador_id INTEGER REFERENCES colaboradores(id)
);

-- Tabela: equipes
CREATE TABLE IF NOT EXISTS equipes (
    id SERIAL PRIMARY KEY,
    data DATE NOT NULL,
    status_composicao TEXT NOT NULL CHECK (status_composicao = ANY (ARRAY['Pendente'::text, 'Aprovada'::text, 'Rejeitada'::text])),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    prefixo CHARACTER VARYING(10) UNIQUE,
    tipo_equipe CHARACTER VARYING DEFAULT 'LV'::character varying NOT NULL CHECK (tipo_equipe::text = ANY (ARRAY['LV'::character varying, 'LM'::character varying, 'PODA'::character varying, 'LM LEVE'::character varying]::text[])),
    encarregado_matricula INTEGER NOT NULL REFERENCES colaboradores(matricula)
);

-- Tabela: composicao_equipe
CREATE TABLE IF NOT EXISTS composicao_equipe (
    id SERIAL PRIMARY KEY,
    equipe_id INTEGER NOT NULL REFERENCES equipes(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    colaborador_matricula INTEGER NOT NULL REFERENCES colaboradores(matricula),
    
    -- Constraint única
    CONSTRAINT composicao_equipe_equipe_id_colaborador_matricula_key UNIQUE (equipe_id, colaborador_matricula)
);

-- Tabela: grupo_itens
CREATE TABLE IF NOT EXISTS grupo_itens (
    id SERIAL PRIMARY KEY,
    grupo TEXT NOT NULL,
    item TEXT NOT NULL,
    unidade TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL
);

-- Tabela: servicos
CREATE TABLE IF NOT EXISTS servicos (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY UNIQUE,
    equipe_id INTEGER NOT NULL REFERENCES equipes(id),
    data_planejada DATE NOT NULL,
    descricao TEXT NOT NULL COMMENT 'Tipo da Nota/Serviço',
    status TEXT NOT NULL CHECK (status = ANY (ARRAY['Planejado'::text, 'Em Deslocamento'::text, 'Aguardando Execução'::text, 'Em Execução'::text, 'Finalizado'::text])),
    inicio_deslocamento TIMESTAMP WITH TIME ZONE,
    fim_deslocamento TIMESTAMP WITH TIME ZONE,
    inicio_execucao TIMESTAMP WITH TIME ZONE,
    fim_execucao TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    equipe_prefixo CHARACTER VARYING(10) CHECK (equipe_prefixo IS NOT NULL AND length(TRIM(BOTH FROM equipe_prefixo)) > 0),
    nota CHARACTER VARYING CHECK (nota IS NOT NULL AND length(TRIM(BOTH FROM nota)) > 0)
);

-- Tabela: giservico
CREATE TABLE IF NOT EXISTS giservico (
    id SERIAL PRIMARY KEY,
    id_servico INTEGER NOT NULL REFERENCES servicos(id),
    id_item INTEGER NOT NULL REFERENCES grupo_itens(id),
    n_serie TEXT,
    status TEXT NOT NULL CHECK (status = ANY (ARRAY['Instalado'::text, 'Retirado'::text])),
    prefixo CHARACTER VARYING(10) REFERENCES equipes(prefixo),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    quantidade INTEGER DEFAULT 1
);

-- Tabela: execucoes_colaborador
CREATE TABLE IF NOT EXISTS execucoes_colaborador (
    id SERIAL PRIMARY KEY,
    servico_id INTEGER NOT NULL REFERENCES servicos(id),
    colaborador_id INTEGER NOT NULL REFERENCES colaboradores(id),
    equipe_id INTEGER NOT NULL REFERENCES equipes(id),
    data_execucao DATE NOT NULL,
    inicio_participacao TIMESTAMP WITH TIME ZONE,
    fim_participacao TIMESTAMP WITH TIME ZONE,
    duracao_minutos INTEGER GENERATED ALWAYS AS (
        CASE
            WHEN ((inicio_participacao IS NOT NULL) AND (fim_participacao IS NOT NULL)) THEN (EXTRACT(epoch FROM (fim_participacao - inicio_participacao)) / (60)::numeric)
            ELSE NULL::numeric
        END
    ) STORED,
    avaliacao_qualidade INTEGER CHECK (avaliacao_qualidade >= 1 AND avaliacao_qualidade <= 5),
    status_participacao TEXT DEFAULT 'Ativo'::text NOT NULL CHECK (status_participacao = ANY (ARRAY['Ativo'::text, 'Ausente'::text, 'Substituído'::text])),
    observacoes TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    
    -- Constraint única
    CONSTRAINT execucoes_colaborador_servico_id_colaborador_id_key UNIQUE (servico_id, colaborador_id)
);

-- Tabela: historico_turno
CREATE TABLE IF NOT EXISTS historico_turno (
    id BIGINT PRIMARY KEY,
    colaborador_matricula INTEGER NOT NULL REFERENCES colaboradores(matricula),
    equipe_prefixo CHARACTER VARYING(10) NOT NULL REFERENCES equipes(prefixo),
    data_turno DATE NOT NULL,
    hora_inicio_turno TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    hora_oper TIMESTAMP WITH TIME ZONE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Constraint única
    CONSTRAINT idx_historico_turno_unique_day_colaborador UNIQUE (colaborador_matricula, data_turno)
);

-- Tabela: servico_header
CREATE TABLE IF NOT EXISTS servico_header (
    id BIGINT PRIMARY KEY,
    servico_id INTEGER UNIQUE NOT NULL REFERENCES servicos(id),
    km_inicial NUMERIC,
    km_final NUMERIC,
    hora_inicial TIME WITHOUT TIME ZONE,
    hora_final TIME WITHOUT TIME ZONE,
    data_execucao DATE,
    equipe_prefixo CHARACTER VARYING(10) REFERENCES equipes(prefixo),
    equipamento TEXT,
    si CHARACTER VARYING,
    ptp CHARACTER VARYING,
    projeto TEXT,
    status_servico CHARACTER VARYING CHECK (status_servico::text = ANY (ARRAY['Pendente'::character varying, 'Em Andamento'::character varying, 'Concluído'::character varying, 'Cancelado'::character varying, 'Pausado'::character varying]::text[])),
    ocorrencia TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tabela: valores_faturamento_real
CREATE TABLE IF NOT EXISTS valores_faturamento_real (
    id SERIAL PRIMARY KEY,
    grupo CHARACTER VARYING NOT NULL,
    item CHARACTER VARYING NOT NULL,
    status CHARACTER VARYING NOT NULL CHECK (status::text = ANY (ARRAY['Instalado'::character varying, 'Retirado'::character varying]::text[])),
    valor_unitario NUMERIC(10,2) NOT NULL,
    unidade CHARACTER VARYING DEFAULT 'UD'::character varying,
    observacoes TEXT,
    created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITHOUT TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- =============================================
-- TRIGGERS
-- =============================================

-- Trigger para auto-geração de ID de serviços (se o ID for TEXT)
-- CREATE OR REPLACE FUNCTION auto_generate_servico_id()
-- RETURNS TRIGGER AS $$
-- BEGIN
--     -- Se ID não foi fornecido, gerar automaticamente
--     IF NEW.id IS NULL THEN
--         NEW.id := generate_servico_id(NEW.nota, NEW.equipe_prefixo);
--     END IF;
    
--     RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql;

-- CREATE TRIGGER trigger_auto_generate_servico_id
--     BEFORE INSERT ON servicos
--     FOR EACH ROW
--     EXECUTE FUNCTION auto_generate_servico_id();

-- =============================================
-- ÍNDICES PARA PERFORMANCE
-- =============================================

-- Índices para colaboradores
CREATE INDEX IF NOT EXISTS idx_colaboradores_coordenador ON colaboradores USING btree (coordenador_id);
CREATE INDEX IF NOT EXISTS idx_colaboradores_funcao ON colaboradores USING btree (funcao);
CREATE INDEX IF NOT EXISTS idx_colaboradores_matricula ON colaboradores USING btree (matricula);
CREATE INDEX IF NOT EXISTS idx_colaboradores_supervisor ON colaboradores USING btree (supervisor_id);

-- Índices para execucoes_colaborador
CREATE INDEX IF NOT EXISTS idx_execucoes_colaborador_colaborador ON execucoes_colaborador USING btree (colaborador_id);
CREATE INDEX IF NOT EXISTS idx_execucoes_colaborador_data ON execucoes_colaborador USING btree (data_execucao);
CREATE INDEX IF NOT EXISTS idx_execucoes_colaborador_equipe ON execucoes_colaborador USING btree (equipe_id);
CREATE INDEX IF NOT EXISTS idx_execucoes_colaborador_servico ON execucoes_colaborador USING btree (servico_id);
CREATE INDEX IF NOT EXISTS idx_execucoes_colaborador_status ON execucoes_colaborador USING btree (status_participacao);

-- Índices para giservico
CREATE INDEX IF NOT EXISTS idx_giservico_id_item ON giservico USING btree (id_item);
CREATE INDEX IF NOT EXISTS idx_giservico_id_servico ON giservico USING btree (id_servico);
CREATE INDEX IF NOT EXISTS idx_giservico_item_status ON giservico USING btree (id_item, status);
CREATE INDEX IF NOT EXISTS idx_giservico_prefixo ON giservico USING btree (prefixo);
CREATE INDEX IF NOT EXISTS idx_giservico_servico_status ON giservico USING btree (id_servico, status);
CREATE INDEX IF NOT EXISTS idx_giservico_status ON giservico USING btree (status);

-- Índices para grupo_itens
CREATE INDEX IF NOT EXISTS idx_grupo_itens_grupo ON grupo_itens USING btree (grupo);
CREATE INDEX IF NOT EXISTS idx_grupo_itens_grupo_item ON grupo_itens USING btree (grupo, item);
CREATE INDEX IF NOT EXISTS idx_grupo_itens_item ON grupo_itens USING btree (item);

-- Índices para historico_turno
CREATE INDEX IF NOT EXISTS idx_historico_turno_colaborador_matricula ON historico_turno USING btree (colaborador_matricula);
CREATE INDEX IF NOT EXISTS idx_historico_turno_equipe_prefixo ON historico_turno USING btree (equipe_prefixo);
-- UNIQUE INDEX already defined as a constraint

-- Índices para servico_header
CREATE INDEX IF NOT EXISTS idx_servico_header_data_execucao ON servico_header USING btree (data_execucao);
CREATE INDEX IF NOT EXISTS idx_servico_header_equipe_prefixo ON servico_header USING btree (equipe_prefixo);
-- No 'turno' column in servico_header from Supabase, so removing this index
-- CREATE INDEX IF NOT EXISTS idx_servico_header_turno ON servico_header USING btree (turno);

-- Índices para servicos
CREATE INDEX IF NOT EXISTS idx_servicos_equipe_data ON servicos USING btree (equipe_prefixo, data_planejada);
CREATE INDEX IF NOT EXISTS idx_servicos_equipe_prefixo ON servicos USING btree (equipe_prefixo);
CREATE INDEX IF NOT EXISTS idx_servicos_nota ON servicos USING btree (nota);
CREATE INDEX IF NOT EXISTS idx_servicos_nota_data ON servicos USING btree (nota, data_planejada);
CREATE INDEX IF NOT EXISTS idx_servicos_nota_equipe ON servicos USING btree (nota, equipe_prefixo);

-- =============================================
-- FUNÇÕES AUXILIARES
-- =============================================

-- Função para gerar ID de serviço (if ID is TEXT)
-- CREATE OR REPLACE FUNCTION generate_servico_id(nota_param TEXT, equipe_prefixo_param TEXT)
-- RETURNS TEXT AS $$
-- DECLARE
--     next_sequence INTEGER;
--     new_id TEXT;
-- BEGIN
--     -- Buscar o próximo número sequencial para esta combinação
--     SELECT COALESCE(MAX(
--         CAST(
--             SUBSTRING(
--                 id FROM '.*-([0-9]+)$'
--             ) AS INTEGER
--         )
--     ), 0) + 1
--     INTO next_sequence
--     FROM servicos 
--     WHERE nota = nota_param 
--     AND equipe_prefixo = equipe_prefixo_param;
    
--     -- Gerar o novo ID
--     new_id := nota_param || '-' || equipe_prefixo_param || '-' || next_sequence;
    
--     RETURN new_id;
-- END;
-- $$ LANGUAGE plpgsql;

-- Função para obter ID da equipe por prefixo
CREATE OR REPLACE FUNCTION get_equipe_id_by_prefixo(prefixo_param TEXT)
RETURNS INTEGER AS $$
DECLARE
    equipe_id_result INTEGER;
BEGIN
    SELECT id INTO equipe_id_result 
    FROM equipes 
    WHERE prefixo = prefixo_param 
    LIMIT 1;
    
    RETURN equipe_id_result;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- FUNÇÕES DE AUTORIZAÇÃO
-- =============================================

-- Função para verificar se usuário é admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  -- Bypass RLS para evitar recursão infinita
  SET LOCAL row_security = off;
  
  RETURN EXISTS (
    SELECT 1 FROM colaboradores 
    WHERE user_id = auth.uid() AND funcao = 'Admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se usuário é coordenador
CREATE OR REPLACE FUNCTION is_coordenador()
RETURNS BOOLEAN AS $$
BEGIN
  -- Bypass RLS para evitar recursão infinita
  SET LOCAL row_security = off;
  
  RETURN EXISTS (
    SELECT 1 FROM colaboradores 
    WHERE user_id = auth.uid() AND funcao = 'Coordenador'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se usuário é supervisor
CREATE OR REPLACE FUNCTION is_supervisor()
RETURNS BOOLEAN AS $$
BEGIN
  -- Bypass RLS para evitar recursão infinita
  SET LOCAL row_security = off;
  
  RETURN EXISTS (
    SELECT 1 FROM colaboradores 
    WHERE user_id = auth.uid() AND funcao = 'Supervisor'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se usuário é encarregado
CREATE OR REPLACE FUNCTION is_encarregado()
RETURNS BOOLEAN AS $$
BEGIN
  -- Bypass RLS para evitar recursão infinita
  SET LOCAL row_security = off;
  
  RETURN EXISTS (
    SELECT 1 FROM colaboradores 
    WHERE user_id = auth.uid() 
    AND UPPER(funcao) LIKE '%ENCARREGADO%'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se usuário está autenticado
CREATE OR REPLACE FUNCTION is_authenticated()
RETURNS BOOLEAN AS $$
  BEGIN
    RETURN (auth.uid() IS NOT NULL);
  END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se encarregado é responsável por uma equipe
CREATE OR REPLACE FUNCTION is_encarregado_da_equipe(equipe_id_param INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
  is_encarregado_equipe BOOLEAN;
BEGIN
  SELECT EXISTS (
    SELECT 1 FROM equipes e
    INNER JOIN colaboradores c ON e.encarregado_matricula = c.matricula
    WHERE e.id = equipe_id_param
    AND c.user_id = auth.uid()
    AND UPPER(c.funcao) LIKE '%ENCARREGADO%'
  ) INTO is_encarregado_equipe;
  RETURN is_encarregado_equipe;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se é encarregado do serviço
CREATE OR REPLACE FUNCTION is_encarregado_do_servico(servico_id_param INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1 FROM servicos s
        JOIN equipes e ON s.equipe_id = e.id
        JOIN colaboradores c ON e.encarregado_matricula = c.matricula
        WHERE s.id = servico_id_param AND c.user_id = auth.uid()
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se pode editar equipe
CREATE OR REPLACE FUNCTION pode_editar_equipe(equipe_id_param INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN is_admin() OR is_coordenador() OR is_supervisor() OR is_encarregado_da_equipe(equipe_id_param);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se pode editar serviço por equipe
CREATE OR REPLACE FUNCTION pode_editar_servico_por_equipe(equipe_id_param INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN is_admin() OR is_coordenador() OR is_supervisor() OR is_encarregado_da_equipe(equipe_id_param);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se pode inserir turno
CREATE OR REPLACE FUNCTION pode_inserir_turno(matricula_alvo INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN is_admin() OR is_coordenador() OR is_supervisor();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se pode ver colaborador
CREATE OR REPLACE FUNCTION pode_ver_colaborador(colaborador_id_param INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN is_admin() OR is_coordenador() OR is_supervisor();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para verificar se pode ver equipe
CREATE OR REPLACE FUNCTION pode_ver_equipe(equipe_id_param INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN is_admin() OR is_coordenador() OR is_supervisor() OR is_encarregado_da_equipe(equipe_id_param);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- FUNÇÕES ADICIONAIS
-- =============================================

-- Função para auto-gerar ID de serviço (if ID is TEXT)
-- CREATE OR REPLACE FUNCTION auto_generate_servico_id()
-- RETURNS trigger AS $$
-- BEGIN
--     IF NEW.id IS NULL OR NEW.id = '' THEN
--         NEW.id := generate_servico_id(NEW.nota, NEW.equipe_prefixo);
--     END IF;
--     RETURN NEW;
-- END;
-- $$ LANGUAGE plpgsql;

-- Função para sincronizar equipe_id a partir do prefixo
CREATE OR REPLACE FUNCTION sync_equipe_id_from_prefixo()
RETURNS trigger AS $$
BEGIN
    IF NEW.equipe_prefixo IS NOT NULL THEN
        NEW.equipe_id := get_equipe_id_by_prefixo(NEW.equipe_prefixo);
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para atualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS trigger AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para registrar execuções automáticas
CREATE OR REPLACE FUNCTION registrar_execucoes_automaticas()
RETURNS trigger AS $$
BEGIN
    -- Registra execução para todos os colaboradores da equipe
    INSERT INTO execucoes_colaborador (servico_id, colaborador_id, equipe_id, data_execucao, status_participacao)
    SELECT 
        NEW.id,
        ce.colaborador_matricula,
        NEW.equipe_id,
        NEW.data_planejada,
        'Presente'
    FROM composicao_equipe ce
    WHERE ce.equipe_id = NEW.equipe_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Função para obter faturamento permitido
CREATE OR REPLACE FUNCTION get_faturamento_permitido()
RETURNS TABLE(grupo text, item text, valor_total numeric) AS $$
BEGIN
    IF is_admin() OR is_coordenador() THEN
        RETURN QUERY
        SELECT gi.grupo, gi.item, SUM(gs.quantidade * vf.valor_unitario) as valor_total
        FROM giservico gs
        JOIN grupo_itens gi ON gs.id_item = gi.id
        LEFT JOIN valores_faturamento_real vf ON (gi.grupo = vf.grupo AND gi.item = vf.item AND gs.status = vf.status)
        WHERE gs.status = 'Instalado' -- Changed from 'Executado' based on Supabase schema
        GROUP BY gi.grupo, gi.item;
    ELSE
        RETURN QUERY
        SELECT ''::text, ''::text, 0::numeric
        WHERE FALSE;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para obter serviços permitidos
CREATE OR REPLACE FUNCTION get_servicos_permitidos()
RETURNS TABLE(id integer, nota character varying, equipe_prefixo character varying, data_planejada date) AS $$
BEGIN
    IF is_admin() OR is_coordenador() OR is_supervisor() THEN
        RETURN QUERY
        SELECT s.id, s.nota, s.equipe_prefixo, s.data_planejada
        FROM servicos s;
    ELSIF is_encarregado() THEN
        RETURN QUERY
        SELECT s.id, s.nota, s.equipe_prefixo, s.data_planejada
        FROM servicos s
        JOIN equipes e ON s.equipe_id = e.id
        JOIN colaboradores c ON e.encarregado_matricula = c.matricula
        WHERE c.user_id = auth.uid();
    ELSE
        RETURN QUERY
        SELECT NULL::integer, ''::character varying, ''::character varying, NULL::date
        WHERE FALSE;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- TRIGGERS ADICIONAIS
-- =============================================

-- Trigger para sincronizar equipe_id nos serviços
CREATE OR REPLACE TRIGGER trigger_sync_equipe_servicos
    BEFORE INSERT OR UPDATE ON servicos
    FOR EACH ROW
    EXECUTE FUNCTION sync_equipe_id_from_prefixo();

-- Trigger para registrar execuções automáticas
CREATE OR REPLACE TRIGGER trigger_registrar_execucoes_automaticas
    AFTER INSERT ON servicos
    FOR EACH ROW
    EXECUTE FUNCTION registrar_execucoes_automaticas();

-- Triggers para updated_at
CREATE OR REPLACE TRIGGER update_colaboradores_updated_at
    BEFORE UPDATE ON colaboradores
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE TRIGGER update_equipes_updated_at
    BEFORE UPDATE ON equipes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE TRIGGER update_servicos_updated_at
    BEFORE UPDATE ON servicos
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE OR REPLACE TRIGGER update_execucoes_updated_at
    BEFORE UPDATE ON execucoes_colaborador
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- VIEWS DE FATURAMENTO
-- =============================================

-- View: vw_faturamento_real
CREATE OR REPLACE VIEW vw_faturamento_real AS
SELECT 
    g.id as giservico_id,
    g.id_servico,
    s.id as servico_id,
    e.prefixo as equipe,
    s.data_planejada as data_servico,
    gi.grupo,
    gi.item,
    g.status,
    g.quantidade,
    g.n_serie,
    vf.valor_unitario,
    vf.unidade,
    vf.observacoes as valor_obs,
    (g.quantidade * COALESCE(vf.valor_unitario, 0)) as valor_total
FROM giservico g
JOIN grupo_itens gi ON g.id_item = gi.id
JOIN servicos s ON g.id_servico = s.id
JOIN equipes e ON s.equipe_id = e.id
LEFT JOIN valores_faturamento_real vf ON (
    gi.grupo = vf.grupo 
    AND gi.item = vf.item 
    AND g.status = vf.status
);

-- View: vw_resumo_faturamento_real
CREATE OR REPLACE VIEW vw_resumo_faturamento_real AS
SELECT 
    equipe,
    data_servico,
    grupo,
    item,
    status,
    SUM(quantidade) as total_quantidade,
    valor_unitario,
    unidade,
    SUM(valor_total) as total_valor
FROM vw_faturamento_real
GROUP BY equipe, data_servico, grupo, item, status, valor_unitario, unidade
ORDER BY equipe, data_servico, grupo, item;

-- View: vw_resumo_faturamento_grupo_real
CREATE OR REPLACE VIEW vw_resumo_faturamento_grupo_real AS
SELECT 
    equipe,
    data_servico,
    grupo,
    SUM(valor_total) as total_grupo
FROM vw_faturamento_real
GROUP BY equipe, data_servico, grupo
ORDER BY equipe, data_servico, grupo;

-- View de composição de equipe detalhada
CREATE OR REPLACE VIEW vw_composicao_equipe_detalhada AS
SELECT 
    e.id as equipe_id,
    e.nome as equipe_nome,
    e.prefixo as equipe_prefixo,
    c.id as colaborador_id,
    c.nome as colaborador_nome,
    c.matricula as colaborador_matricula,
    c.funcao as colaborador_funcao
FROM equipes e
JOIN composicao_equipe ce ON e.id = ce.equipe_id
JOIN colaboradores c ON ce.colaborador_matricula = c.matricula;

-- View de equipes com encarregados
CREATE OR REPLACE VIEW vw_equipes_com_encarregados AS
SELECT 
    e.*,
    encarregado.nome as encarregado_nome
FROM equipes e
LEFT JOIN colaboradores encarregado ON e.encarregado_matricula = encarregado.matricula;

-- View de serviços com hierarquia
CREATE OR REPLACE VIEW vw_servicos_com_hierarquia AS
SELECT 
    s.*,
    e.nome as equipe_nome,
    encarregado.nome as encarregado_nome
FROM servicos s
JOIN equipes e ON s.equipe_id = e.id
LEFT JOIN colaboradores encarregado ON e.encarregado_matricula = encarregado.matricula;

-- View de métricas de equipe por data
CREATE OR REPLACE VIEW vw_metricas_equipe_data AS
SELECT 
    s.equipe_prefixo,
    s.data_planejada,
    COUNT(s.id) as total_servicos,
    COUNT(CASE WHEN s.status = 'Finalizado' THEN 1 END) as servicos_concluidos, -- Changed from 'Concluído'
    SUM(CASE WHEN gs.status = 'Instalado' THEN gs.quantidade * COALESCE(vf.valor_unitario, 0) ELSE 0 END) as faturamento_realizado -- Changed from 'Executado'
FROM servicos s
LEFT JOIN giservico gs ON s.id = gs.id_servico
LEFT JOIN grupo_itens gi ON gs.id_item = gi.id
LEFT JOIN valores_faturamento_real vf ON (gi.grupo = vf.grupo AND gi.item = vf.item AND gs.status = vf.status)
GROUP BY s.equipe_prefixo, s.data_planejada;

-- View de produção por colaborador
CREATE OR REPLACE VIEW vw_producao_colaborador AS
SELECT 
    c.id as colaborador_id,
    c.nome as colaborador_nome,
    c.matricula,
    COUNT(ec.id) as total_servicos_executados,
    SUM(CASE WHEN gs.status = 'Instalado' THEN gs.quantidade * COALESCE(vf.valor_unitario, 0) ELSE 0 END) as valor_produzido -- Changed from 'Executado'
FROM colaboradores c
JOIN execucoes_colaborador ec ON c.id = ec.colaborador_id
JOIN giservico gs ON ec.servico_id = gs.id_servico
JOIN grupo_itens gi ON gs.id_item = gi.id
LEFT JOIN valores_faturamento_real vf ON (gi.grupo = vf.grupo AND gi.item = vf.item AND gs.status = vf.status)
WHERE ec.status_participacao = 'Ativo' -- Changed from 'Presente'
GROUP BY c.id, c.nome, c.matricula;

-- =============================================
-- COMENTÁRIOS DAS TABELAS
-- =============================================

-- Comentários para a tabela colaboradores
COMMENT ON TABLE colaboradores IS 'Tabela que armazena informações dos colaboradores da empresa';
COMMENT ON COLUMN colaboradores.id IS 'Identificador único do colaborador';
COMMENT ON COLUMN colaboradores.nome IS 'Nome completo do colaborador';
COMMENT ON COLUMN colaboradores.matricula IS 'Matrícula única do colaborador';
COMMENT ON COLUMN colaboradores.funcao IS 'Função do colaborador (Admin, Coordenador, Supervisor, Encarregado, Operador)';
COMMENT ON COLUMN colaboradores.user_id IS 'ID do usuário no sistema de autenticação';
COMMENT ON COLUMN colaboradores.coordenador_id IS 'Referência ao coordenador responsável';
COMMENT ON COLUMN colaboradores.supervisor_id IS 'Referência ao supervisor responsável';
COMMENT ON COLUMN colaboradores.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN colaboradores.updated_at IS 'Data e hora da última atualização';

-- Comentários para a tabela equipes
COMMENT ON TABLE equipes IS 'Tabela que armazena informações das equipes de trabalho';
COMMENT ON COLUMN equipes.id IS 'Identificador único da equipe';
COMMENT ON COLUMN equipes.data IS 'Data da equipe'; -- Added based on Supabase schema
COMMENT ON COLUMN equipes.nome IS 'Nome da equipe'; -- Removed based on Supabase schema
COMMENT ON COLUMN equipes.prefixo IS 'Prefixo único da equipe usado para identificação';
COMMENT ON COLUMN equipes.encarregado_matricula IS 'Matrícula do encarregado da equipe';
COMMENT ON COLUMN equipes.tipo_equipe IS 'Tipo da equipe (LV, LM, PODA, LM LEVE)'; -- Updated based on Supabase schema
COMMENT ON COLUMN equipes.status_composicao IS 'Status da composição da equipe (Pendente, Aprovada, Rejeitada)'; -- Updated based on Supabase schema
COMMENT ON COLUMN equipes.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN equipes.updated_at IS 'Data e hora da última atualização';

-- Comentários para a tabela composicao_equipe
COMMENT ON TABLE composicao_equipe IS 'Tabela que relaciona colaboradores com suas equipes';
COMMENT ON COLUMN composicao_equipe.equipe_id IS 'Referência à equipe';
COMMENT ON COLUMN composicao_equipe.colaborador_matricula IS 'Matrícula do colaborador';
COMMENT ON COLUMN composicao_equipe.data_inicio IS 'Data de início na equipe'; -- Removed based on Supabase schema
COMMENT ON COLUMN composicao_equipe.data_fim IS 'Data de saída da equipe'; -- Removed based on Supabase schema
COMMENT ON COLUMN composicao_equipe.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN composicao_equipe.updated_at IS 'Data e hora da última atualização'; -- Added based on Supabase schema

-- Comentários para a tabela grupo_itens
COMMENT ON TABLE grupo_itens IS 'Tabela que armazena os grupos de itens de serviço';
COMMENT ON COLUMN grupo_itens.id IS 'Identificador único do item';
COMMENT ON COLUMN grupo_itens.grupo IS 'Nome do grupo do item';
COMMENT ON COLUMN grupo_itens.item IS 'Nome do item específico';
COMMENT ON COLUMN grupo_itens.descricao IS 'Descrição detalhada do item'; -- Removed based on Supabase schema
COMMENT ON COLUMN grupo_itens.unidade IS 'Unidade de medida'; -- Added based on Supabase schema
COMMENT ON COLUMN grupo_itens.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN grupo_itens.updated_at IS 'Data e hora da última atualização';

-- Comentários para a tabela servicos
COMMENT ON TABLE servicos IS 'Tabela que armazena os serviços planejados';
COMMENT ON COLUMN servicos.id IS 'Identificador único do serviço (gerado automaticamente)';
COMMENT ON COLUMN servicos.nota IS 'Número da nota de serviço';
COMMENT ON COLUMN servicos.equipe_prefixo IS 'Prefixo da equipe responsável';
COMMENT ON COLUMN servicos.equipe_id IS 'ID da equipe (sincronizado automaticamente)';
COMMENT ON COLUMN servicos.data_planejada IS 'Data planejada para execução do serviço';
COMMENT ON COLUMN servicos.status IS 'Status do serviço (Planejado, Em Deslocamento, Aguardando Execução, Em Execução, Finalizado)'; -- Updated based on Supabase schema
COMMENT ON COLUMN servicos.descricao IS 'Tipo da Nota/Serviço'; -- Updated based on Supabase schema
COMMENT ON COLUMN servicos.inicio_deslocamento IS 'Início do deslocamento'; -- Added based on Supabase schema
COMMENT ON COLUMN servicos.fim_deslocamento IS 'Fim do deslocamento'; -- Added based on Supabase schema
COMMENT ON COLUMN servicos.inicio_execucao IS 'Início da execução'; -- Added based on Supabase schema
COMMENT ON COLUMN servicos.fim_execucao IS 'Fim da execução'; -- Added based on Supabase schema
COMMENT ON COLUMN servicos.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN servicos.updated_at IS 'Data e hora da última atualização';

-- Comentários para a tabela giservico
COMMENT ON TABLE giservico IS 'Controle de itens utilizados nos serviços (instalados ou retirados)'; -- Updated based on Supabase schema
COMMENT ON COLUMN giservico.id IS 'Chave primária única'; -- Updated based on Supabase schema
COMMENT ON COLUMN giservico.id_servico IS 'Referência ao serviço (FK para servicos.id)'; -- Updated based on Supabase schema
COMMENT ON COLUMN giservico.id_item IS 'Referência ao item do grupo (FK para grupo_itens.id)'; -- Updated based on Supabase schema
COMMENT ON COLUMN giservico.quantidade IS 'Quantidade do item instalado ou retirado.'; -- Updated based on Supabase schema
COMMENT ON COLUMN giservico.status IS 'Status do item: Instalado ou Retirado'; -- Updated based on Supabase schema
COMMENT ON COLUMN giservico.n_serie IS 'Número de série do item (opcional)'; -- Updated based on Supabase schema
COMMENT ON COLUMN giservico.prefixo IS 'Prefixo da equipe (FK para equipes.prefixo)'; -- Updated based on Supabase schema
COMMENT ON COLUMN giservico.created_at IS 'Data e hora de criação do registro';

-- Comentários para a tabela execucoes_colaborador
COMMENT ON TABLE execucoes_colaborador IS 'Registra a participação individual de cada colaborador em serviços para métricas de produtividade'; -- Updated based on Supabase schema
COMMENT ON COLUMN execucoes_colaborador.id IS 'Identificador único da execução';
COMMENT ON COLUMN execucoes_colaborador.servico_id IS 'Referência ao serviço executado';
COMMENT ON COLUMN execucoes_colaborador.colaborador_id IS 'Referência ao colaborador';
COMMENT ON COLUMN execucoes_colaborador.equipe_id IS 'Referência à equipe';
COMMENT ON COLUMN execucoes_colaborador.data_execucao IS 'Data da execução do serviço';
COMMENT ON COLUMN execucoes_colaborador.inicio_participacao IS 'Início da participação no serviço'; -- Added based on Supabase schema
COMMENT ON COLUMN execucoes_colaborador.fim_participacao IS 'Fim da participação no serviço'; -- Added based on Supabase schema
COMMENT ON COLUMN execucoes_colaborador.duracao_minutos IS 'Duração da participação em minutos'; -- Added based on Supabase schema
COMMENT ON COLUMN execucoes_colaborador.status_participacao IS 'Status da participação (Ativo, Ausente, Substituído)'; -- Updated based on Supabase schema
COMMENT ON COLUMN execucoes_colaborador.avaliacao_qualidade IS 'Avaliação da qualidade do trabalho (1-5)';
COMMENT ON COLUMN execucoes_colaborador.observacoes IS 'Observações sobre a execução';
COMMENT ON COLUMN execucoes_colaborador.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN execucoes_colaborador.updated_at IS 'Data e hora da última atualização';

-- Comentários para a tabela historico_turno
COMMENT ON TABLE historico_turno IS 'Tabela que armazena o histórico de turnos dos colaboradores';
COMMENT ON COLUMN historico_turno.id IS 'Identificador único do registro de turno';
COMMENT ON COLUMN historico_turno.colaborador_matricula IS 'Matrícula do colaborador';
COMMENT ON COLUMN historico_turno.equipe_prefixo IS 'Prefixo da equipe';
COMMENT ON COLUMN historico_turno.data_turno IS 'Data do turno';
COMMENT ON COLUMN historico_turno.hora_inicio_turno IS 'Hora de início do turno'; -- Added based on Supabase schema
COMMENT ON COLUMN historico_turno.hora_oper IS 'Hora de operação'; -- Added based on Supabase schema
COMMENT ON COLUMN historico_turno.turno IS 'Tipo de turno (Manhã, Tarde, Noite)'; -- Removed based on Supabase schema
COMMENT ON COLUMN historico_turno.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN historico_turno.updated_at IS 'Data e hora da última atualização';

-- Comentários para a tabela servico_header
COMMENT ON TABLE servico_header IS 'Tabela para armazenar dados de cabeçalho de conclusão de serviços'; -- Updated based on Supabase schema
COMMENT ON COLUMN servico_header.id IS 'Identificador único do cabeçalho';
COMMENT ON COLUMN servico_header.servico_id IS 'Referência ao serviço (relacionamento 1:1)'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.km_inicial IS 'Quilometragem inicial do veículo'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.km_final IS 'Quilometragem final do veículo'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.hora_inicial IS 'Hora de início da execução'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.hora_final IS 'Hora de fim da execução'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.data_execucao IS 'Data de execução do serviço'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.equipe_prefixo IS 'Prefixo da equipe responsável';
COMMENT ON COLUMN servico_header.equipamento IS 'Descrição do equipamento utilizado'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.si IS 'Sistema de Informação'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.ptp IS 'Permissão de Trabalho Programado'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.projeto IS 'Notas e descrição do projeto'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.status_servico IS 'Status atual do serviço'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.ocorrencia IS 'Descrição de ocorrências durante a execução'; -- Added based on Supabase schema
COMMENT ON COLUMN servico_header.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN servico_header.updated_at IS 'Data e hora da última atualização';

-- Comentários para a tabela valores_faturamento_real
COMMENT ON TABLE valores_faturamento_real IS 'Tabela que armazena os valores reais de faturamento por item e status';
COMMENT ON COLUMN valores_faturamento_real.id IS 'Identificador único do registro';
COMMENT ON COLUMN valores_faturamento_real.grupo IS 'Grupo do item';
COMMENT ON COLUMN valores_faturamento_real.item IS 'Nome do item';
COMMENT ON COLUMN valores_faturamento_real.status IS 'Status para o qual o valor se aplica';
COMMENT ON COLUMN valores_faturamento_real.valor_unitario IS 'Valor unitário real para faturamento';
COMMENT ON COLUMN valores_faturamento_real.unidade IS 'Unidade de medida';
COMMENT ON COLUMN valores_faturamento_real.observacoes IS 'Observações sobre o valor';
COMMENT ON COLUMN valores_faturamento_real.created_at IS 'Data e hora de criação do registro';
COMMENT ON COLUMN valores_faturamento_real.updated_at IS 'Data e hora da última atualização';

-- =============================================
-- POLÍTICAS DE SEGURANÇA (RLS)
-- =============================================

-- Habilitar RLS nas tabelas principais
ALTER TABLE colaboradores ENABLE ROW LEVEL SECURITY;
ALTER TABLE equipes ENABLE ROW LEVEL SECURITY;
ALTER TABLE servicos ENABLE ROW LEVEL SECURITY;
ALTER TABLE giservico ENABLE ROW LEVEL SECURITY;
ALTER TABLE execucoes_colaborador ENABLE ROW LEVEL SECURITY;
ALTER TABLE historico_turno ENABLE ROW LEVEL SECURITY;
ALTER TABLE servico_header ENABLE ROW LEVEL SECURITY;
ALTER TABLE valores_faturamento_real ENABLE ROW LEVEL SECURITY;

-- Políticas para colaboradores
CREATE POLICY "Colaboradores podem ver próprios dados" ON colaboradores
    FOR SELECT USING (user_id = auth.uid() OR is_admin() OR is_coordenador() OR is_supervisor());

CREATE POLICY "Admins podem gerenciar colaboradores" ON colaboradores
    FOR ALL USING (is_admin());

-- Políticas para equipes
CREATE POLICY "Usuários podem ver equipes permitidas" ON equipes
    FOR SELECT USING (is_admin() OR is_coordenador() OR is_supervisor() OR is_encarregado_da_equipe(id));

CREATE POLICY "Hierarquia pode editar equipes" ON equipes
    FOR ALL USING (is_admin() OR is_coordenador() OR is_supervisor());

-- Políticas para serviços
CREATE POLICY "Usuários podem ver serviços permitidos" ON servicos
    FOR SELECT USING (is_admin() OR is_coordenador() OR is_supervisor() OR is_encarregado_do_servico(id));

CREATE POLICY "Hierarquia pode gerenciar serviços" ON servicos
    FOR ALL USING (is_admin() OR is_coordenador() OR is_supervisor() OR pode_editar_servico_por_equipe(equipe_id));

-- =============================================
-- FINALIZAÇÃO DO SCHEMA
-- =============================================

-- Schema atualizado em: 2025-08-21
-- Versão: 2.1
-- Descrição: Schema completo do banco de dados de operações
-- Inclui: tabelas, índices, funções, triggers, views e políticas de segurança
